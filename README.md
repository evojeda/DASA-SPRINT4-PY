# DASA-SPRINT4-PY

Com os dados definidos demanda diária igual a [4, 6, 3, 5], estoque inicial de 10 unidades, reposição máxima por dia de 8 unidades, nível-alvo de 10 unidades, custo de falta de 10 por unidade não atendida, custo de excesso de 2 por unidade acima do alvo e custos operacionais de 1 por unidade resposta e 0,5 por unidade estocada ao fim do dia o problema é decidir, em cada dia, quanto repor para minimizar a soma dos custos de falta, excesso, pedido e manutenção. O estado relevante em cada etapa é o estoque no início do dia; a decisão é a quantidade a repor antes do consumo; a transição resulta do balanço estoque + reposição − consumo, truncada em zero para não carregar estoque negativo, o custo do dia soma o pedido feito, a manutenção do estoque remanescente e eventuais penalidades por falta ou por excesso acima do alvo.
A versão recursiva percorre esse espaço de decisões de forma direta, partindo do dia 0 com estoque 10. No dia 0, repor é desnecessário porque o consumo é 4 e já há estoque suficiente; a melhor ação local, vista pelo algoritmo, é repor 0, deixando o estoque em 6 ao fim do dia e incorrendo apenas no custo de manutenção de 3,0 (0,5×6). No dia 1, o estoque de 6 atende exatamente o consumo de 6, de modo que, novamente, repor 0 é ótimo naquele ponto; o estoque zera ao final e o custo do dia 1 é 0. A partir do dia 2, como o estoque começa em 0 e o consumo é 3, o algoritmo compara a falta (que custaria 30) com repor a quantidade exata. Repor 3 elimina a falta e evita sobra, gerando custo de 3 pelo pedido e zero de manutenção. No dia 3, a mesma lógica se repete para o consumo de 5: repor 5 atende completamente a demanda sem sobra, com custo de pedido 5 e manutenção 0. A soma dos quatro dias fica então em 3 + 0 + 3 + 5 = 11,0. Essa sequência de decisões, [0, 0, 3, 5], é exatamente o que a recursão encontra como ótima porque qualquer antecipação de reposição elevaria o custo de manutenção sem reduzir os pedidos futuros o suficiente para compensar. Por exemplo, repor no dia 1 para “adiantar” parte do dia 2 adicionaria custo de pedido e ainda geraria manutenção intermediária, aumentando o total.
A versão com memoização resolve os mesmos subproblemas, mas evita recalcular custos já vistos para a mesma combinação de dia e estoque. O raciocínio econômico permanece idêntico e, por isso, o resultado final é o mesmo. Quando a função chega ao estado (dia 2, estoque 0), ela registra que repor exatamente 3 é superior a qualquer outra quantidade, pois repor menos acarreta a penalidade de falta, muito cara, e repor mais carrega estoque que custa 0,5 por unidade sem trazer vantagem futura, já que o próximo consumo de 5 pode ser perfeitamente atendido com uma reposição pontual no dia 3. Do mesmo modo, no estado (dia 3, estoque 0), repor 5 é ótimo porque elimina falta e não deixa sobra. Esses valores ficam memorizados e, quando estados iguais reaparecem durante a exploração, são reutilizados, garantindo eficiência sem alterar a política ótima.
A versão iterativa bottom-up constrói a mesma solução de trás para frente. Começa fixando que, após o último dia, o custo futuro é zero para qualquer estoque; depois calcula, para cada estoque possível no dia 3, o custo mínimo de decidir repor entre 0 e 8 unidades antes do consumo de 5. Com estoque 0 nesse dia, o melhor é repor 5, gerando custo 5. Em seguida, com base nessa tabela do dia 3, calcula os valores do dia 2 para cada estoque possível; com estoque 0 e consumo 3, repor 3 custa 3 naquele dia e, como a transição leva a estoque 0 no dia 3, soma-se o custo ótimo já conhecido do dia 3 (5), confirmando o total parcial 8 a partir do dia 2. Repetindo o processo para os dias 1 e 0, chega-se ao mesmo encadeamento de decisões que a recursão havia escolhido: não repor quando já há estoque suficiente (dias 0 e 1), repor exatamente o consumo quando o estoque está zerado (dias 2 e 3). Ao terminar a tabela, o valor em dp[0][10] reflete o custo ótimo total e coincide com 11,0.
O motivo econômico de a tríade de algoritmos produzir exatamente 11,0 é a relação entre os pesos de custo e a cronologia da demanda. A falta é extremamente cara, então o modelo evita faltar; por outro lado, manter estoque custa 0,5 por unidade ao dia e repor custa 1 por unidade, de modo que antecipar reposições para “ter folga” só aumentaria a soma de pedido e manutenção sem benefício, já que as demandas futuras podem ser atendidas na data exata com a mesma ou menor despesa. Como o estoque inicial cobre os dois primeiros dias sem necessidade de compras (com custo total de manutenção de 3 no dia 0 e 0 no dia 1), e como os dois últimos dias começam com estoque 0, a estratégia ótima é justamente comprar sob demanda: 3 unidades no dia 2 e 5 unidades no dia 3. A decomposição diária confirma o resultado final: três unidades mantidas ao fim do dia 0 custam 3, nenhuma despesa no dia 1, três unidades pedidas no dia 2 custam 3 e cinco unidades pedidas no dia 3 custam 5; não há falta nem excesso em nenhum dia, e a soma desses valores entrega o mínimo global de 11,0.

